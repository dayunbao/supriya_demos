"""
Copyright 2025, Andrew Clark

This program is free software: you can redistribute it and/or modify 
it under the terms of the GNU General Public License as published by 
the Free Software Foundation, either version 3 of the License, or 
(at your option) any later version.

This program is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
GNU General Public License for more details.

You should have received a copy of the GNU General Public License 
along with this program. If not, see <https://www.gnu.org/licenses/>.
"""

"""
Plateau Reverb (Dattorro Digital Reverb Variant)

This implementation is a highly optimized and customized version of the classic
Dattorro digital reverb algorithm, using a fixed-gain AllpassN structure 
for stability and incorporating the Integrator UGen for accurate 1-pole damping.

## âš™ï¸ Inputs (Controls)

| Parameter | Type | Range | Role and Description |
| :--- | :--- | :--- | :--- |
| **in_bus** | int | N/A | Input audio bus (stereo source assumed). |
| **out_bus** | int | N/A | Output audio bus (stereo destination). |
| **pre_delay** | float | 0.0 - 0.5s | Time delay before the reverberation starts. |
| **size** | float | 0.0 - 1.0 | Scales all delay line lengths in the tank and diffusers, controlling the virtual room size and modal density. |
| **decay** | float | 0.0 - 1.0 | Controls the overall energy decay (RT60). A higher value results in a longer tail. |
| **diffusion** | float | 0.0 - 10.0 | Scales the Allpass filter gains (up to 0.7) inside the main feedback tank, controlling the rate of sound diffusion. |
| **input_low_cut** | float | 0.0 - 10.0 | High-pass filter frequency for the **input signal**, reducing rumble before reverb processing. |
| **input_high_cut** | float | 0.0 - 10.0 | Low-pass filter frequency for the **input signal**, limiting input bandwidth. |
| **reverb_high_cut** | float | 0.0 - 10.0 | **Damping Control (LPF):** Coefficient for the 1-pole low-pass filter (implemented via Integrator) inside the tank. Controls high-frequency decay time. |
| **reverb_low_cut** | float | 0.0 - 10.0 | **Bass Decay Control (HPF):** Frequency of the High-Pass Filter inside the tank, controlling how quickly bass frequencies decay. |
| **mod_speed** | float | 0.0 - 1.0 | Speed/frequency of the LFOs used to modulate tank delay times, increasing chorus/movement. |
| **mod_depth** | float | 0.0 - 1.0 | Amplitude/excursion of the LFO modulation applied to tank delay times. |
| **mod_shape** | float | 0.0 - 1.0 | Fades between SinOsc (0.0) and LFNoise2 (1.0) for the modulation source. |
| **dry** | float | 0.0 - 1.0 | Gain for the unprocessed input signal. |
| **wet** | float | 0.0 - 1.0 | Gain for the processed reverb signal (scaled internally by 10.0). |

---

## ðŸ” Signal Flow (High-Level Structure)

1.  **Input & Pre-Processing:** Stereo input is mixed to mono, applied with `pre_delay`, and filtered by `input_low_cut` and `input_high_cut`.
2.  **Input Diffusion Stage:** The processed mono signal is fed through **8 series AllpassN filters** to create a dense wash of early reflections.
3.  **Stereo Tank Entry:** The diffused signal is blended with the cross-fed signal from the opposite tank (using an `input_attenuation` of 0.5) and enters the stereo tank structure.
4.  **Feedback Tank (L/R):** This is the core engine, a modified FBCF (Feedback Comb Filter) loop for each channel, with a cross-feedback path.
    * **APF 1:** Modulated Allpass filter (Decay Diffusion 1).
    * **Delay Line 1:** Long delay line.
    * **Damping Filters:** **Integrator (LPF)** and **HPF** applied to control high and low-frequency decay.
    * **APF 2:** Modulated Allpass filter (Decay Diffusion 2).
    * **Delay Line 2:** Long delay line.
5.  **Feedback Loop:** The output of Delay Line 2 is scaled by the overall `decay_scaled` factor, **inverted** (multiplied by -1), and sent back to the opposite tank's input via `LocalOut`/`LocalIn`.
6.  **Output Stage:** The final stereo output is generated by mixing 8 distinct, time-delayed taps from various points within the **Left Tank** and **Cross-Taps** from the **Right Tank** (and vice-versa), combined with the original `dry` signal.

---

## ðŸŽ¯ Differences from the Original Dattorro Algorithm

The original Dattorro paper specifies a theoretical model. This implementation deviates in several pragmatic ways to achieve better stability, density, and parameter control:

1.  **Fixed-Gain Allpass Filters:**
    * **Original:** Relied heavily on the $\text{AllpassC}$ UGen's RT60 parameter for gain control, which can be computationally complex and prone to numerical instability near unity gain.
    * **This Version:** Uses the **$\text{AllpassN}$ UGen** (Non-interpolating), which allows the direct, fixed Dattorro gain coefficient to be set via the `decay_time` argument (e.g., 0.75 or 0.625), ensuring perfect gain control and stability.

2.  **Increased Input Diffusion Density:**
    * **Original:** Uses **4** input allpass filters.
    * **This Version:** Uses **8 series allpass filters** for input diffusion. This significantly increases the density of early reflections, resulting in a smoother, more dense onset of the reverberation tail.

3.  **Damping Filter Implementation:**
    * **Original:** Specifies a simple 1-pole $\text{LPF}$ inside the tank loop.
    * **This Version:** Implements the $\text{LPF}$ damping precisely using the **$\text{Integrator}$ UGen** (fed by an attenuated signal), directly translating the successful technique used in the external SuperCollider implementation.
    * **Custom Bass Decay:** Incorporates a dedicated **$\text{HPF}$** (controlled by `reverb_low_cut`) inside the tank to manage low-frequency decay, a common modern enhancement for tonal control.

4.  **Simplified Negation:**
    * **Original Topology:** Often applies negation/inversion around the first allpass filter in the tank.
    * **This Version:** Applies a single **negation (multiplication by -1)** only to the signal entering the cross-feedback loop via $\text{LocalOut}$, simplifying the signal path and maintaining the required stability of the FBCF structure.

       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚               PLATEAU REVERB SIGNAL FLOW                 â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
  [STEREO IN] 
           â”‚ (Mix to Mono)
           â–¼
     [PRE-DELAY & FILTERS] (Input HPF/LPF)
           â”‚
           â–¼ (8x AllpassN in Series)
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘                 INPUT DIFFUSION STAGE                   â•‘
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           â”‚ (Diffused Mono Signal)
           â–¼
      [INPUT BLEND] (x0.5 Attenuation)
           â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                    â”‚
  â–¼                    â–¼
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  LEFT TANK INPUT â•‘ â•‘ RIGHT TANK INPUT â•‘
â•‘ (Blended w/ R FB)â•‘ â•‘ (Blended w/ L FB)â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â”‚                      â”‚
    â–¼                      â–¼
[APF 1] (Modulated)    [APF 1] (Modulated)
    â”‚                      â”‚
[Delay Line 1]         [Delay Line 1]
    â”‚                      â”‚
    â–¼                      â–¼
[INTEGRATOR] (LPF Damping)
    â”‚
[HPF DAMPING] (Low-Cut)
    â”‚
[APF 2] (Modulated)    [APF 2] (Modulated)
    â”‚                      â”‚
[Delay Line 2]         [Delay Line 2]
    â”‚                      â”‚
    â–¼                      â–¼
[APF 3] (Final Diff.)  [APF 3] (Final Diff.)
    â”‚                      â”‚
    â–¼                      â–¼
(Attenuate by Decay)   (Attenuate by Decay)
    â”‚                      â”‚
(NEGATE x -1)            (NEGATE x -1)
    â”‚                      â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼           â”‚  â”‚                   â–¼
[LOCAL OUT (L)] â”‚  â”‚         [LOCAL OUT (R)]
    â”‚           â”‚  â”‚                   â”‚
    â”‚  â—€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚â—„â”€â”€â”˜
           CROSS-FEEDBACK LOOP 
                                   
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                   â”‚
    â–¼                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ L-TANK OUTPUT TAPS â”‚ â”‚ R-TANK OUTPUT TAPS â”‚
â”‚ (8 Taps from L&R)  â”‚ â”‚ (8 Taps from L&R)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚                      â”‚
    â–¼                      â–¼
[WET SIGNAL L]          [WET SIGNAL R]
    â”‚                      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
            â”‚       â”‚
      [Dry Signal L/R]
            â”‚       â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
    â–¼                       â–¼
   [STEREO OUT (L)]     [STEREO OUT (R)]
    
"""

from supriya import synthdef
from supriya.ugens import (
    AllpassN,
    DelayC,
    Envelope,
    EnvGen,
    HPF,
    In,
    Integrator,
    LFNoise2,
    LFSaw,
    Limiter,
    LinExp,
    LinLin,
    LocalIn,
    LocalOut,
    LPF,
    Out,
    SinOsc,
)

# Dattorro reference sample rate
DATTORRO_SR = 29761.0

# Fixed coefficients from Dattorro paper (input diffusion stays fixed)
INPUT_DIFFUSION_1 = 0.75
INPUT_DIFFUSION_2 = 0.625
# Tank diffusion max from Dattorro paper
MAX_TANK_DIFFUSION = 0.7

# LFO max excursion (samples)
LFO_MAX_EXCURSION = 16.0


def pitch_to_frequency(pitch):
    """
    Convert pitch value (0-10) to frequency in Hz using LinExp.
    """
    # Map pitch (0-10) to frequency (13.75-14080 Hz) using exponential curve
    return LinExp.kr(
        source=pitch,
        input_minimum=0.0,
        input_maximum=10.0,
        output_minimum=13.75,
        output_maximum=14080.0
    )

@synthdef()
def dattorro_reverb(
    in_bus: int = 2,
    out_bus: int = 0,
    pre_delay: float = 0.0,
    size: float = 0.5,
    decay: float = 0.54995,
    diffusion: float = 10.0,
    input_low_cut: float = 10.0,
    input_high_cut: float = 10.0,
    reverb_low_cut: float = 10.0,
    reverb_high_cut: float = 10.0,
    mod_speed: float = 0.0,
    mod_depth: float = 0.5,
    mod_shape: float = 0.5,
    dry: float = 1.0,
    wet: float = 0.5,
):

    # Apply quadratic decay curve (from Plateau.cpp)
    decay_factor = 1.0 - decay
    decay_scaled = 1.0 - (decay_factor * decay_factor)

    # Apply wet gain scaling (multiply by 10.0 from Plateau.cpp)
    wet_scaled = wet * 10.0

    # Scale tank diffusion: 0-10 â†’ 0-0.7
    tank_diffusion = (diffusion / 10.0) * MAX_TANK_DIFFUSION

    # Damping Coefficient: 0-10 pitch maps to 0-1 for Integrator
    # The SCLang code uses a single damping param (0-0.999), 
    # we use reverb_high_cut for this.
    damping_coef = reverb_high_cut / 10.0

    # Convert remaining damping/filtering pitch values (0-10) to Hz
    input_low_cut_hz = pitch_to_frequency(input_low_cut)
    input_high_cut_hz = pitch_to_frequency(input_high_cut)
    
    # Note: reverb_low_cut_hz is not used in the final Integrator model, 
    # but we'll calculate it for completeness if needed later.
    reverb_low_cut_hz = pitch_to_frequency(reverb_low_cut) 


    # Read stereo input
    input_signal = In.ar(bus=in_bus, channel_count=2)
    dry_signal = input_signal

    # Convert stereo to mono for processing
    mono_input = (input_signal[0] + input_signal[1]) * 0.5

    # Pre-delay (up to 0.5 seconds)
    if pre_delay > 0.001:
        pre_delayed = DelayC.ar(source=mono_input, maximum_delay_time=0.5, delay_time=pre_delay)
    else:
        pre_delayed = mono_input

    # Input bandwidth filtering
    # NOTE: The SCLang code uses Integrator/OnePole here (approx. LPF)
    filtered = pre_delayed
    if input_low_cut_hz > 20.0:
        filtered = HPF.ar(source=filtered, frequency=input_low_cut_hz)
    if input_high_cut_hz < 20000.0:
        # Using LPF as a generic bandwidth control (per previous model)
        filtered = LPF.ar(source=filtered, frequency=input_high_cut_hz) 

    # INPUT DIFFUSION: 8 allpass filters in series using fixed Dattorro gains
    scale = size
    
    # --- Diffuser 1: 141 samples, gain = 0.75 ---
    d1_time = (141.0 / DATTORRO_SR) * scale
    diffuser_1 = AllpassN.ar( 
        source=filtered,
        maximum_delay_time=0.1,
        delay_time=d1_time,
        decay_time=INPUT_DIFFUSION_1
    )

    # --- Diffuser 2: 107 samples, gain = 0.75 ---
    d2_time = (107.0 / DATTORRO_SR) * scale
    diffuser_2 = AllpassN.ar( 
        source=diffuser_1,
        maximum_delay_time=0.1,
        delay_time=d2_time,
        decay_time=INPUT_DIFFUSION_1
    )

    # --- Diffuser 3: 379 samples, gain = 0.625 ---
    d3_time = (379.0 / DATTORRO_SR) * scale
    diffuser_3 = AllpassN.ar( 
        source=diffuser_2,
        maximum_delay_time=0.2,
        delay_time=d3_time,
        decay_time=INPUT_DIFFUSION_2
    )

    # --- Diffuser 4: 277 samples, gain = 0.625 ---
    d4_time = (277.0 / DATTORRO_SR) * scale
    diffuser_4 = AllpassN.ar( 
        source=diffuser_3,
        maximum_delay_time=0.2,
        delay_time=d4_time,
        decay_time=INPUT_DIFFUSION_2
    )

    # Additional diffusers (using 0.625 fixed gain)
    # --- Diffuser 5: 509 samples, gain = 0.625 ---
    d5_time = (509.0 / DATTORRO_SR) * scale
    diffuser_5 = AllpassN.ar(
        source=diffuser_4,
        maximum_delay_time=0.2,
        delay_time=d5_time,
        decay_time=INPUT_DIFFUSION_2
    )

    # --- Diffuser 6: 337 samples, gain = 0.625 ---
    d6_time = (337.0 / DATTORRO_SR) * scale
    diffuser_6 = AllpassN.ar(
        source=diffuser_5,
        maximum_delay_time=0.2,
        delay_time=d6_time,
        decay_time=INPUT_DIFFUSION_2
    )

    # --- Diffuser 7: 449 samples, gain = 0.625 ---
    d7_time = (449.0 / DATTORRO_SR) * scale
    diffuser_7 = AllpassN.ar(
        source=diffuser_6,
        maximum_delay_time=0.2,
        delay_time=d7_time,
        decay_time=INPUT_DIFFUSION_2
    )

    # --- Diffuser 8: 601 samples, gain = 0.625 ---
    d8_time = (601.0 / DATTORRO_SR) * scale
    diffuser_8 = AllpassN.ar(
        source=diffuser_7,
        maximum_delay_time=0.3,
        delay_time=d8_time,
        decay_time=INPUT_DIFFUSION_2
    )

    diffused_input = diffuser_8

    # --- MODULATION OSCILLATORS ---
    mod_scale = 1.0 + (mod_speed * 9.0)

    # Using LFNoise2 for noise modulation, matching SCLang
    lfo_1 = SinOsc.kr(frequency=1.0 * mod_scale)
    lfo_2 = SinOsc.kr(frequency=1.5 * mod_scale)
    lfo_3 = SinOsc.kr(frequency=1.2 * mod_scale)
    lfo_4 = SinOsc.kr(frequency=1.8 * mod_scale)

    noise_1 = LFNoise2.kr(frequency=2.0 * mod_scale) # <--- LFNoise2 used here
    noise_2 = LFNoise2.kr(frequency=3.0 * mod_scale) # <--- LFNoise2 used here
    noise_3 = LFNoise2.kr(frequency=2.4 * mod_scale) # <--- LFNoise2 used here
    noise_4 = LFNoise2.kr(frequency=3.6 * mod_scale) # <--- LFNoise2 used here

    mod_1 = LinLin.kr(source=mod_shape, input_minimum=0.0, input_maximum=1.0, output_minimum=lfo_1, output_maximum=noise_1)
    mod_2 = LinLin.kr(source=mod_shape, input_minimum=0.0, input_maximum=1.0, output_minimum=lfo_2, output_maximum=noise_2)
    mod_3 = LinLin.kr(source=mod_shape, input_minimum=0.0, input_maximum=1.0, output_minimum=lfo_3, output_maximum=noise_3)
    mod_4 = LinLin.kr(source=mod_shape, input_minimum=0.0, input_maximum=1.0, output_minimum=lfo_4, output_maximum=noise_4)

    mod_depth_samples = (mod_depth / 16.0) * (LFO_MAX_EXCURSION / DATTORRO_SR) * scale

    mod_1_scaled = mod_1 * mod_depth_samples
    mod_2_scaled = mod_2 * mod_depth_samples
    mod_3_scaled = mod_3 * mod_depth_samples
    mod_4_scaled = mod_4 * mod_depth_samples


    # --- STEREO TANK with feedback using LocalIn/LocalOut ---
    feedback = LocalIn.ar(channel_count=2)
    input_attenuation = 0.5 

    # ============ LEFT TANK ============
    # SCLang mixing: input + local[1]
    left_input = (diffused_input * input_attenuation) + feedback[1]

    # Decay diffusion 1 (modulated allpass) - 672 samples, gain = tank_diffusion
    left_apf_1_delay = (672.0 / DATTORRO_SR) * scale + mod_1_scaled
    
    # NOTE: No Negation on source input here, per SCLang's simpler negation logic
    left_apf_1 = AllpassN.ar(
        source=left_input, # <--- SOURCE NOT NEGATED
        maximum_delay_time=0.2,
        delay_time=left_apf_1_delay,
        decay_time=tank_diffusion
    )
    # NOTE: The subsequent negation on left_apf_1 is also REMOVED

    # Additional allpass for more diffusion - 823 samples, gain = tank_diffusion
    left_apf_1b_delay = (823.0 / DATTORRO_SR) * scale
    left_apf_1b = AllpassN.ar(
        source=left_apf_1,
        maximum_delay_time=0.2,
        delay_time=left_apf_1b_delay,
        decay_time=tank_diffusion
    )

    # Delay line 1 - 4453 samples
    left_delay_1 = DelayC.ar(
        source=left_apf_1b,
        maximum_delay_time=0.5,
        delay_time=(4453.0 / DATTORRO_SR) * scale
    )

    # Damping Filter (One-Pole LPF via Integrator, matching SCLang)
    # SCLang logic: Integrator.ar(tank0 * ( 1 - damping ), damping) * decay;
    left_damped = Integrator.ar(
        source=left_delay_1 * (1.0 - damping_coef),
        coefficient=damping_coef
    )

    left_damped_filtered = left_damped
    if reverb_low_cut_hz > 20.0:
        left_damped_filtered = HPF.ar(source=left_damped_filtered, frequency=reverb_low_cut_hz)

    # Additional allpass between delay1 and apf2 - 419 samples, gain = tank_diffusion
    left_apf_1c_delay = (419.0 / DATTORRO_SR) * scale
    left_apf_1c = AllpassN.ar( 
        source=left_damped_filtered, # <--- Damped signal feeds here
        maximum_delay_time=0.2,
        delay_time=left_apf_1c_delay,
        decay_time=tank_diffusion
    )

    # Decay diffusion 2 (modulated allpass) - 1800 samples, gain = +tank_diffusion
    left_apf_2_delay = (1800.0 / DATTORRO_SR) * scale + mod_2_scaled
    left_apf_2 = AllpassN.ar(
        source=left_apf_1c,
        maximum_delay_time=0.2,
        delay_time=left_apf_2_delay,
        decay_time=tank_diffusion
    )

    # Delay line 2 - 3720 samples
    left_delay_2 = DelayC.ar(
        source=left_apf_2,
        maximum_delay_time=0.5,
        delay_time=(3720.0 / DATTORRO_SR) * scale
    )

    # Additional allpass after delay 2 - 521 samples, gain = tank_diffusion
    left_apf_3_delay = (521.0 / DATTORRO_SR) * scale
    left_apf_3 = AllpassN.ar(
        source=left_delay_2,
        maximum_delay_time=0.2,
        delay_time=left_apf_3_delay,
        decay_time=tank_diffusion
    )

    # Output for feedback (attenuated by decay)
    left_feedback = left_apf_3 * decay_scaled

    # ============ RIGHT TANK ============
    # SCLang mixing: input + local[0]
    right_input = (diffused_input * input_attenuation) + feedback[0]

    # Decay diffusion 1 (modulated allpass) - 908 samples, gain = tank_diffusion
    right_apf_1_delay = (908.0 / DATTORRO_SR) * scale + mod_3_scaled
    
    # NOTE: No Negation on source input here, per SCLang's simpler negation logic
    right_apf_1 = AllpassN.ar(
        source=right_input, # <--- SOURCE NOT NEGATED
        maximum_delay_time=0.2,
        delay_time=right_apf_1_delay,
        decay_time=tank_diffusion
    )
    # NOTE: The subsequent negation on right_apf_1 is also REMOVED

    # Additional allpass for more diffusion - 727 samples, gain = tank_diffusion
    right_apf_1b_delay = (727.0 / DATTORRO_SR) * scale
    right_apf_1b = AllpassN.ar(
        source=right_apf_1,
        maximum_delay_time=0.2,
        delay_time=right_apf_1b_delay,
        decay_time=tank_diffusion
    )

    # Delay line 1 - 4217 samples
    right_delay_1 = DelayC.ar(
        source=right_apf_1b,
        maximum_delay_time=0.5,
        delay_time=(4217.0 / DATTORRO_SR) * scale
    )

    # Damping Filter (One-Pole LPF via Integrator, matching SCLang)
    right_damped = Integrator.ar(
        source=right_delay_1 * (1.0 - damping_coef),
        coefficient=damping_coef
    )

    right_damped_filtered = right_damped
    if reverb_low_cut_hz > 20.0:
        right_damped_filtered = HPF.ar(source=right_damped_filtered, frequency=reverb_low_cut_hz)

    # Additional allpass between delay1 and apf2 - 491 samples, gain = tank_diffusion
    right_apf_1c_delay = (491.0 / DATTORRO_SR) * scale
    right_apf_1c = AllpassN.ar(
        source=right_damped_filtered,
        maximum_delay_time=0.2,
        delay_time=right_apf_1c_delay,
        decay_time=tank_diffusion
    )

    # Decay diffusion 2 (modulated allpass) - 2656 samples, gain = +tank_diffusion
    right_apf_2_delay = (2656.0 / DATTORRO_SR) * scale + mod_4_scaled
    right_apf_2 = AllpassN.ar(
        source=right_apf_1c,
        maximum_delay_time=0.2,
        delay_time=right_apf_2_delay,
        decay_time=tank_diffusion
    )

    # Delay line 2 - 3163 samples
    right_delay_2 = DelayC.ar(
        source=right_apf_2,
        maximum_delay_time=0.5,
        delay_time=(3163.0 / DATTORRO_SR) * scale
    )

    # Additional allpass after delay 2 - 617 samples, gain = tank_diffusion
    right_apf_3_delay = (617.0 / DATTORRO_SR) * scale
    right_apf_3 = AllpassN.ar(
        source=right_delay_2,
        maximum_delay_time=0.2,
        delay_time=right_apf_3_delay,
        decay_time=tank_diffusion
    )

    # Output for feedback (attenuated by decay)
    right_feedback = right_apf_3 * decay_scaled

    # Close the feedback loop (send decay-attenuated and NEGATED signals)
    # SCLang: tank0 * -1, tank1 * -1
    LocalOut.ar(source=[left_feedback * -1, right_feedback * -1]) # <--- NEGATION APPLIED HERE

    # --- OUTPUT TAPS ---
    # The output taps use the raw APF outputs (n_out_1 to n_out_6 equivalent)
    # The SCLang code refers to n_out_1, n_out_2, n_out_3 from Tank 0, 
    # and n_out_4, n_out_5, n_out_6 from Tank 1. 

    # Left tank equivalents: left_apf_1 (n_out_4 in SCLang cross-mix), left_damped (n_out_5), left_apf_1c (n_out_6), left_apf_2 (n_out_3)
    # Right tank equivalents: right_apf_1 (n_out_1), right_damped (n_out_2), right_apf_1c (n_out_3), right_apf_2 (n_out_6)
    
    # We will use the UGen names closest to the tap points from the Supriya structure:
    # L-Taps: left_apf_1, left_delay_1, left_apf_2 (using left_delay_2 as an end-of-chain tap)
    # R-Taps: right_apf_1, right_delay_1, right_apf_2 (using right_delay_2 as an end-of-chain tap)

    # Left output (Mix of L taps and Cross R taps)
    left_wet = (
        # From right channel (n_out_4, n_out_4, n_out_5.neg, n_out_6) 
        # Taps from Right Tank's APF1, APF1, Damping (Delay1), APF1c
        0.6 * DelayC.ar(source=right_apf_1, maximum_delay_time=0.3, delay_time=(266.0 / DATTORRO_SR) * scale) +
        0.6 * DelayC.ar(source=right_apf_1, maximum_delay_time=0.3, delay_time=(2974.0 / DATTORRO_SR) * scale) +
        -0.6 * DelayC.ar(source=right_delay_1, maximum_delay_time=0.5, delay_time=(1913.0 / DATTORRO_SR) * scale) + # Using delay1 for n_out_5 equivalent
        0.6 * DelayC.ar(source=right_apf_1c, maximum_delay_time=0.3, delay_time=(1996.0 / DATTORRO_SR) * scale) +
        
        # From left channel (Cross-taps: n_out_1.neg, n_out_2.neg, n_out_3.neg, tank0.neg) 
        # Taps from Left Tank's APF1, Damping (Delay1), APF1c, Final Delay2
        -0.6 * DelayC.ar(source=left_apf_1, maximum_delay_time=0.5, delay_time=(1990.0 / DATTORRO_SR) * scale) +
        -0.6 * DelayC.ar(source=left_delay_1, maximum_delay_time=0.3, delay_time=(187.0 / DATTORRO_SR) * scale) + # Using delay1 for n_out_2 equivalent
        -0.6 * DelayC.ar(source=left_apf_1c, maximum_delay_time=0.5, delay_time=(1066.0 / DATTORRO_SR) * scale) + # Using APF1c for n_out_3 equivalent
        -0.6 * left_delay_2 # Using delay2 for tank0 equivalent (final delay)
    )

    # Right output (Mix of R taps and Cross L taps)
    right_wet = (
        # From left channel (n_out_1, n_out_1, n_out_2.neg, n_out_3)
        # Taps from Left Tank's APF1, APF1, Damping (Delay1), APF1c
        0.6 * DelayC.ar(source=left_apf_1, maximum_delay_time=0.3, delay_time=(353.0 / DATTORRO_SR) * scale) +
        0.6 * DelayC.ar(source=left_apf_1, maximum_delay_time=0.3, delay_time=(3627.0 / DATTORRO_SR) * scale) +
        -0.6 * DelayC.ar(source=left_delay_1, maximum_delay_time=0.5, delay_time=(1228.0 / DATTORRO_SR) * scale) + # Using delay1 for n_out_2 equivalent
        0.6 * DelayC.ar(source=left_apf_1c, maximum_delay_time=0.3, delay_time=(2673.0 / DATTORRO_SR) * scale) +
        
        # From right channel (Cross-taps: n_out_4.neg, n_out_5.neg, n_out_6.neg, tank1.neg)
        # Taps from Right Tank's APF1, Damping (Delay1), APF1c, Final Delay2
        -0.6 * DelayC.ar(source=right_apf_1, maximum_delay_time=0.5, delay_time=(2111.0 / DATTORRO_SR) * scale) +
        -0.6 * DelayC.ar(source=right_delay_1, maximum_delay_time=0.5, delay_time=(335.0 / DATTORRO_SR) * scale) + # Using delay1 for n_out_5 equivalent
        -0.6 * DelayC.ar(source=right_apf_1c, maximum_delay_time=0.5, delay_time=(121.0 / DATTORRO_SR) * scale) + # Using APF1c for n_out_6 equivalent
        -0.6 * right_delay_2 # Using delay2 for tank1 equivalent (final delay)
    )


    # DC blocking on outputs (20 Hz HPF)
    left_wet = HPF.ar(source=left_wet, frequency=20.0)
    right_wet = HPF.ar(source=right_wet, frequency=20.0)

    # Combine dry and wet (wet is scaled by 10.0)
    left_out = (dry_signal[0] * dry) + (left_wet * wet_scaled)
    right_out = (dry_signal[1] * dry) + (right_wet * wet_scaled)

    # Output stereo signal
    Out.ar(bus=out_bus, source=[left_out, right_out])

@synthdef()
def saw(amplitude=0.5, frequency=440.0, out_bus=0) -> None:
    """Args:
        amplitude: the volume.
        frequency: the frequency in hertz of a note.
        out_bus: where to direct audio output.
        
    """
    signal = LFSaw.ar(frequency=[frequency, frequency - 2])
    signal *= amplitude
    signal = Limiter.ar(level=0.1, source=signal)

    env = EnvGen.kr(envelope=Envelope.percussive(), done_action=2)
    signal *= env

    Out.ar(bus=out_bus, source=signal)